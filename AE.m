%% ============================================================================
%  ISAC End-to-End Autoencoder - MATLAB Data Generation + Python Training
%  
%  WORKFLOW:
%    1. Run this script in MATLAB to generate training data
%    2. Run train_isac_ae.py in Python to train the neural networks
%    3. Results and plots are generated by Python
%  
%  This hybrid approach gives better training results than pure MATLAB.
% ============================================================================
clc; clear; close all;
rng('default');

fprintf('=== ISAC Data Generator (for Python Training) ===\n\n');

%% ========== SYSTEM PARAMETERS (Section IV.A) ==========
K = 16;                              % Number of antennas
M = 4;                               % Message alphabet size |M|
Etx = 1;                             % Transmit power constraint
lambda = 0.125;                      % Wavelength (2.4 GHz carrier)
d_nominal = lambda/2;                % Nominal antenna spacing

% Angular ranges (Section IV.A)
theta_min = deg2rad(-20);            % Target AoA minimum
theta_max = deg2rad(20);             % Target AoA maximum  
vartheta_min = deg2rad(30);          % Comm receiver AoD minimum
vartheta_max = deg2rad(50);          % Comm receiver AoD maximum

% SNR parameters
SNRc_dB = 20;                        % Communication SNR (dB)
SNRr_dB = 0;                         % Radar SNR (dB)
N0 = 1;                              % Noise PSD
sigma_c2 = N0 * 10^(SNRc_dB/10);     % Channel variance for comm
sigma_r2 = N0 * 10^(SNRr_dB/10);     % Channel variance for radar

% Data generation parameters
numTrainSamples = 500000;            % Training samples
numTestSamples = 50000;              % Test samples
p_target = 0.5;                      % Prior probability of target presence

% Hardware impairments parameters (Section IV.E)
sigma_lambda = lambda/30;            % Antenna spacing perturbation std
enable_hardware_impairments = true;  % Enable/disable impairments

% omega_r values for evaluation
omega_r_values = [0, 0.01, 0.014, 0.015, 0.03, 0.09, 0.15, 0.4, 0.6, 0.7, 1];

fprintf('Parameters:\n');
fprintf('  K=%d antennas, M=%d messages\n', K, M);
fprintf('  SNR_c=%.0f dB, SNR_r=%.0f dB\n', SNRc_dB, SNRr_dB);
fprintf('  Training samples: %d, Test samples: %d\n', numTrainSamples, numTestSamples);
fprintf('  Hardware impairments: %s\n\n', string(enable_hardware_impairments));

%% ========== GENERATE ANTENNA SPACING ==========
if enable_hardware_impairments
    d_spacings = d_nominal + sigma_lambda * randn(K-1, 1);
    fprintf('Hardware impairments ENABLED (sigma_lambda = lambda/30)\n');
else
    d_spacings = d_nominal * ones(K-1, 1);
    fprintf('Hardware impairments DISABLED\n');
end

%% ========== GENERATE TRAINING DATA ==========
fprintf('\nGenerating training data...\n');
train = generate_data(numTrainSamples, K, M, ...
    theta_min, theta_max, vartheta_min, vartheta_max, ...
    sigma_r2, sigma_c2, N0, Etx, p_target, ...
    d_spacings, d_nominal, lambda, enable_hardware_impairments);
fprintf('Training data generated: %d samples\n', numTrainSamples);

%% ========== GENERATE TEST DATA ==========
fprintf('Generating test data...\n');
test = generate_data(numTestSamples, K, M, ...
    theta_min, theta_max, vartheta_min, vartheta_max, ...
    sigma_r2, sigma_c2, N0, Etx, p_target, ...
    d_spacings, d_nominal, lambda, enable_hardware_impairments);
fprintf('Test data generated: %d samples\n', numTestSamples);

%% ========== SAVE PARAMETERS ==========
params.K = K;
params.M = M;
params.Etx = Etx;
params.lambda = lambda;
params.d_nominal = d_nominal;
params.d_spacings = d_spacings;
params.theta_min = theta_min;
params.theta_max = theta_max;
params.vartheta_min = vartheta_min;
params.vartheta_max = vartheta_max;
params.SNRc_dB = SNRc_dB;
params.SNRr_dB = SNRr_dB;
params.N0 = N0;
params.sigma_c2 = sigma_c2;
params.sigma_r2 = sigma_r2;
params.p_target = p_target;
params.enable_hardware_impairments = enable_hardware_impairments;
params.omega_r_values = omega_r_values;

%% ========== SAVE TO .MAT FILE ==========
fprintf('\nSaving to isac_data.mat...\n');
save('isac_data.mat', 'train', 'test', 'params', '-v7');  % v7 for scipy compatibility

fprintf('\n========================================\n');
fprintf('Data saved to: isac_data.mat\n');
fprintf('========================================\n');
fprintf('\nNext step: Run Python training\n');
fprintf('  >> python train_isac_ae.py\n');
fprintf('========================================\n');

%% ============================================================================
%  DATA GENERATION FUNCTION
% ============================================================================
function data = generate_data(N, K, M, ...
    theta_min, theta_max, vartheta_min, vartheta_max, ...
    sigma_r2, sigma_c2, N0, Etx, p_target, ...
    d_spacings, d_nominal, lambda, enable_hw)
    
    % Generate labels
    data.m_idx = randi(M, N, 1);                                    % Message index (1 to M)
    data.target_present = double(rand(N, 1) < p_target);            % Target presence
    data.theta_true = theta_min + rand(N, 1) * (theta_max - theta_min);
    data.vartheta_true = vartheta_min + rand(N, 1) * (vartheta_max - vartheta_min);
    
    % Channel coefficients
    data.alpha = sqrt(sigma_r2/2) * (randn(N, 1) + 1j * randn(N, 1));  % Radar
    data.beta = sqrt(sigma_c2/2) * (randn(N, 1) + 1j * randn(N, 1));   % Comm
    
    % Generate transmit signal (random beamformer for data generation)
    % Use ISAC-style beamformer with average angles
    theta_c = (theta_min + theta_max) / 2;
    vartheta_c = (vartheta_min + vartheta_max) / 2;
    
    if enable_hw
        a_r = steer_vec_impaired(theta_c, K, d_spacings, lambda);
        a_c = steer_vec_impaired(vartheta_c, K, d_spacings, lambda);
    else
        a_r = steer_vec(theta_c, K, d_nominal, lambda);
        a_c = steer_vec(vartheta_c, K, d_nominal, lambda);
    end
    
    omega_r = 0.5;  % Balanced for data generation
    v = sqrt(omega_r) * a_r + sqrt(1 - omega_r) * a_c;
    v = sqrt(Etx) * v / norm(v);  % K x 1 column vector
    
    % 4-QAM constellation
    qam = [1+1j, 1-1j, -1+1j, -1-1j] / sqrt(2);
    x = reshape(qam(data.m_idx), 1, []);  % Force to 1 x N row vector
    
    % Transmit signal
    y = v * x;  % (K x 1) * (1 x N) = K x N
    
    % Radar channel simulation
    Y_radar = zeros(N, K);
    for n = 1:N
        if enable_hw
            a_tx = steer_vec_impaired(data.theta_true(n), K, d_spacings, lambda);
        else
            a_tx = steer_vec(data.theta_true(n), K, d_nominal, lambda);
        end
        
        inner_prod = a_tx' * y(:, n);
        zr = data.target_present(n) * data.alpha(n) * a_tx * inner_prod;
        zr = zr + sqrt(N0/2) * (randn(K, 1) + 1j * randn(K, 1));
        Y_radar(n, :) = zr.';
    end
    data.Y_radar = Y_radar;
    
    % Communication channel simulation
    Y_comm = zeros(N, 1);
    kappa = zeros(N, 1);  % Effective channel for CSI
    for n = 1:N
        if enable_hw
            a_tx = steer_vec_impaired(data.vartheta_true(n), K, d_spacings, lambda);
        else
            a_tx = steer_vec(data.vartheta_true(n), K, d_nominal, lambda);
        end
        
        kappa(n) = data.beta(n) * (a_tx' * v);
        zc = kappa(n) * x(n);
        zc = zc + sqrt(N0/2) * (randn + 1j * randn);
        Y_comm(n) = zc;
    end
    data.Y_comm = Y_comm;
    data.kappa = kappa;  % CSI for comm receiver
    
    fprintf('  Generated %d samples\n', N);
end

function A = steer_vec(theta, K, d, lambda)
    n = (0:K-1).';
    A = exp(-1j * 2 * pi * n * (d/lambda) * sin(theta));
end

function A = steer_vec_impaired(theta, K, d_spacings, lambda)
    positions = [0; cumsum(d_spacings)];
    A = exp(-1j * 2 * pi / lambda * positions * sin(theta));
end
